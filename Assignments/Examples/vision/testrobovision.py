##########################
#Import Modules
##########################
import numpy
import match
from enum import Enum
import GripPipeline
import cv2
import time
from networktables import NetworkTable
import logging
logging.basicConfig(level=logging.DEBUG)
##########################
#Setup Variables
##########################
oPipe = GripPipeline.GripPipeline()

capture = cv2.VideoCapture(0)

NetworkTable.setIPAddress("10.61.62.103")
#NetworkTable.setPort(1185)
NetworkTable.setClientMode()
#NetworkTable.setTeam(6162);
NetworkTable.initialize()
sd = NetworkTable.getTable("VisionResults")

f = open("datarobovision.txt", 'w')

##########################
#Functions
##########################
def findSimilar(r):
#This function is designed to take a list generated by inserting x, y, w and h values from 
#cv.  Each rectangle found generates these four values and appends them to the list.
#r, the list, should have a multiple of 4 values

	#Discard the list if it has less than 8 values:
	if len(r) <= 7:
		return []
	#If it has eight or more values, then two rectangles may have been found.
	if len(r) >=8:
		#To analyse, make a 2D array of values corresponding, in size, to the number of shapes found by cv
		size = len(r)/4
		#Limit to a particular number of shapes to avoid processing lag.
		if size>10:
			size = 10
		#Create the array
		comparisonArray = [[0 for x in range(size)] for y in range(size)]
		#Compare ratios of y, w and h:
		for i in range(0,size):
			for j in range(0,size):
				if i==j:
					comparisonArray[i][j] = 100
				else:
					comparisonArray[i][j] = abs(1.0-1.0*r[4*i+1]/r[4*j+1]*r[4*i+2]/r[4*j+2]*r[4*i+3]/r[4*j+3])
		#Find the ratio closed to 1; assume that this corresponds to two rectangles
		minimum = comparisonArray[0][0]
		r1 = 0
		r2 = 0
		for i in range(0,size):
			for j in range(0,size):
				if comparisonArray[i][j] < minimum and i != j:
					r1 = i
					r2 = j
		#Send back a list of two rectangles - the two that are closest in size
		rectangles = [r[r1],r[r1+1],r[r1+2],r[r1+3],r[r2],r[r2+1],r[r2+2],r[r2+3]]
		return rectangles




##########################
#Loop
##########################
for i in range(0,500):
	ret, imgFrame = capture.read()
	oPipe.process(imgFrame)
	print i , ", FilterLength: ", len(oPipe.filter_contours_output), " FindLength: ", len(oPipe.find_contours_output)
	rectangles = []
	for mxContour in oPipe.find_contours_output:
		x,y,w,h=cv2.boundingRect(mxContour)
		print("Found: x={} y={} w={} h={}").format(x,y,w,h)
		rectangles.append(x)
		rectangles.append(y)
		rectangles.append(w)
		rectangles.append(h)
	rectangles = findSimilar(rectangles)
	writeText = "Photo: "+str(i)+" Size: "+str(len(rectangles))+"\n"
	f.write(writeText)
	print rectangles
	for item in range(0,len(rectangles)):
		f.write(str(rectangles[item])+", ")
	f.write("\n")
	sd.putNumberArray("RectanglesFound", rectangles)

capture.release()
f.close()
print "Finished"


